"""
OpenAPI Schema Utilities for AquaMind

This module provides utilities for modifying and enhancing OpenAPI schemas,
particularly for compatibility with different database backends.

The primary focus is on making schemas compatible with SQLite in CI environments
by limiting integer ranges to prevent overflow errors during testing.
"""
import logging
from typing import Dict, Any, Optional, List, Union

# Define SQLite integer limits
# SQLite stores INTEGER values as 64-bit signed integers
SQLITE_MAX_INT = 9223372036854775807  # 2^63 - 1
SQLITE_MIN_INT = -9223372036854775808  # -2^63

logger = logging.getLogger(__name__)


def clamp_integer_schema_bounds(
    result: Dict[str, Any],
    *,
    generator: Any = None,
    request: Any = None,
    public: bool | None = None,
    **kwargs,
) -> Dict[str, Any]:
    """
    Post-processing hook for drf-spectacular that clamps integer fields to SQLite's safe range.
    
    This function is designed to be used as a post-processing hook in drf-spectacular's
    SPECTACULAR_SETTINGS to ensure that all integer fields in the schema have bounds
    that are compatible with SQLite's INTEGER storage limitations.
    
    This signature follows drf-spectacular's post-processing hook contract
    (``hook(result=..., generator=..., request=..., public=...)``). Only the
    ``result`` parameter is used – the others are accepted for compatibility.

    Args:
        result: The OpenAPI schema dictionary to modify
        
    Returns:
        The modified schema with integer bounds clamped to SQLite's safe range
        
    Example:
        # In settings_ci.py:
        SPECTACULAR_SETTINGS = {
            'POSTPROCESSING_HOOKS': [
                'aquamind.utils.openapi_utils.clamp_integer_schema_bounds',
            ],
        }
    """
    logger.info("Applying SQLite integer bounds to OpenAPI schema")
    
    # spectacular passes the schema in ``result`` – keep original name for
    # clarity in the rest of the function.
    schema = result

    # Process components schemas
    if 'components' in schema and 'schemas' in schema['components']:
        _process_schema_objects(schema['components']['schemas'])
    
    # Process path parameters and responses
    if 'paths' in schema:
        _process_paths(schema['paths'])
    
    return schema


def ensure_global_security(
    result: Dict[str, Any],
    *,
    generator: Any = None,
    request: Any = None,
    public: bool | None = None,
    **kwargs,
) -> Dict[str, Any]:
    """
    Post-processing hook that guarantees the presence of a *global* ``security``
    requirement in the generated OpenAPI spec.

    Some tooling (including Schemathesis) relies on a top-level ``security``
    block to decide which authentication headers to send by default.  While
    drf-spectacular infers `components.securitySchemes` from DRF
    authentication classes, it will emit the top-level list only if *every*
    view explicitly declares a requirement — an easily missed detail that
    results in anonymous requests during contract testing.

    This hook ensures that the schema always contains::

        security:
          - tokenAuth: []

    If a different or more specific set of schemes is already present, the hook
    leaves it untouched.
    """
    schema = result  # alias

    # Add the global security block only if it is missing or empty
    if not schema.get("security"):
        logger.info("Adding global tokenAuth security requirement to OpenAPI schema")
        schema["security"] = [{"tokenAuth": []}]

    return schema


def cleanup_duplicate_security(
    result: Dict[str, Any],
    *,
    generator: Any = None,
    request: Any = None,
    public: bool | None = None,
    **kwargs,
) -> Dict[str, Any]:
    """
    Post-processing hook that removes duplicate entries in the ``security`` arrays
    generated by drf-spectacular.

    During schema generation we sometimes end up with repeated ``tokenAuth`` (or
    other) entries per operation which does not violate the spec but confuses
    certain tooling (e.g. Schemathesis & some code generators).  This hook
    normalises each ``security`` list so that every distinct scheme appears only
    once while preserving the original order.

    The signature follows drf-spectacular's post-processing contract.
    Only the ``result`` (the full schema) is mutated.
    """
    logger.info("De-duplicating security requirements in OpenAPI schema")

    schema = result  # alias for clarity

    # Endpoints that legitimately allow anonymous access.  Keep the "{}"
    # placeholder for these so that contract-testing tools know anonymous
    # requests are valid here.
    EXEMPT_ANON_PATHS = {
        "/api/v1/auth/token/",
        "/api/v1/auth/dev-auth/",
    }

    def _deduplicate(security_list: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Return a list with duplicates removed (order preserved)."""
        seen: List[Dict[str, Any]] = []
        for item in security_list:
            if item not in seen:
                seen.append(item)
        return seen

    # Deduplicate top-level security (if present)
    if "security" in schema and isinstance(schema["security"], list):
        schema["security"] = _deduplicate(schema["security"])

    # Deduplicate per-operation security requirements
    # Iterate with both *path* and *path_item* so we can reference the path
    # later when deciding whether to strip anonymous access.
    for path, path_item in schema.get("paths", {}).items():
        for method, operation in path_item.items():
            if method in {
                "get",
                "post",
                "put",
                "delete",
                "patch",
                "head",
                "options",
                "trace",
            }:
                if "security" in operation and isinstance(operation["security"], list):
                    operation["security"] = _deduplicate(operation["security"])

                    # -----------------------------------------------------------------
                    # Strip anonymous access ("{}") except for explicitly whitelisted
                    # endpoints such as the authentication views.
                    # -----------------------------------------------------------------
                    if path not in EXEMPT_ANON_PATHS:
                        operation["security"] = [
                            entry for entry in operation["security"] if entry
                        ]

    return schema

def prune_legacy_paths(
    result: Dict[str, Any],
    *,
    generator: Any = None,
    request: Any = None,
    public: bool | None = None,
    **kwargs,
) -> Dict[str, Any]:
    """
    Post-processing hook that **removes every path** beginning with
    ``/api/v1/infrastructure/`` from the generated OpenAPI schema.

    Why remove the whole prefix?
    ----------------------------
    During **Phase 4 – API Contract Unification** the *infrastructure* API
    surface was migrated to the new batch-centric design.  The underlying
    Django routers have been deleted, yet drf-spectacular still discovers the
    (now-stale) viewsets via historical imports, leading to hundreds of `404`
    failures in Schemathesis runs.

    Stripping the entire prefix at schema-generation time guarantees the
    contract reflects only live endpoints without needing to micro-manage an
    ever-growing allow/deny list.
    """

    schema = result  # alias for clarity

    paths_dict = schema.get("paths", {})
    if not paths_dict:  # Nothing to do
        return schema

    removed_paths: list[str] = []

    # Cast to list to avoid 'dictionary changed size during iteration'
    for path in list(paths_dict.keys()):
        if path.startswith("/api/v1/infrastructure/"):
            removed_paths.append(path)
            paths_dict.pop(path, None)

    if removed_paths:
        logger.info("Pruned legacy infrastructure paths from OpenAPI schema: %s",
                    removed_paths)

    return schema

def add_validation_error_responses(
    result: Dict[str, Any],
    *,
    generator: Any = None,
    request: Any = None,
    public: bool | None = None,
    **kwargs,
) -> Dict[str, Any]:
    """
    *Minimal* post-processing hook that documents **400 Validation errors**
    where they are most likely to occur, without over-broadening the spec.
    
    Strategy
    --------
    1. Add a ``400`` response to every **POST / PUT / PATCH** operation
       (payload validation errors are always possible here).
    2. Add a ``400`` response to **GET** operations that expose a ``page``
       query parameter (pagination rejects ``page=0`` & non-ints).
    
    That’s it – no 401 / 422 / 500 handling here.  Keep it small; expand only
    if the test suite shows clear gaps.
    """
    logger.info("Adding minimal 400-validation responses to OpenAPI schema")
    
    schema = result  # alias for clarity
    
    error_400_schema = {
        "description": "Bad request (validation error)"
    }
    
    # Process all paths and operations
    for path, path_item in schema.get("paths", {}).items():
        for method, operation in path_item.items():
            if method not in {
                "get", "post", "put", "delete", "patch", "head", "options", "trace"
            }:
                continue
                
            # Get or initialize the responses object
            if "responses" not in operation:
                operation["responses"] = {}
            responses = operation["responses"]
            
            # ------------------------------------------------------------------
            # (1) Always for write-methods
            # (2) GET + explicit `page` parameter
            # ------------------------------------------------------------------
            if method in {"post", "put", "patch"}:
                needs_400 = True
            elif method == "get":
                needs_400 = any(
                    isinstance(p, dict) and p.get("name") == "page"
                    for p in operation.get("parameters", [])
                )
            else:
                needs_400 = False

            if needs_400 and "400" not in responses:
                responses["400"] = error_400_schema
    
    return schema

def _process_schema_objects(schemas: Dict[str, Any]) -> None:
    """
    Recursively process schema objects to clamp integer bounds.
    
    Args:
        schemas: Dictionary of schema objects to process
    """
    for schema_name, schema_obj in schemas.items():
        _process_schema_object(schema_obj)


def _process_schema_object(schema_obj: Dict[str, Any]) -> None:
    """
    Process a single schema object to clamp integer bounds.
    
    Args:
        schema_obj: Schema object to process
    """
    # Handle direct integer type
    if schema_obj.get('type') == 'integer':
        _clamp_integer_bounds(schema_obj)
    
    # Handle properties in objects
    if 'properties' in schema_obj:
        for prop_name, prop_schema in schema_obj['properties'].items():
            if isinstance(prop_schema, dict):
                _process_schema_object(prop_schema)
    
    # Handle array items
    if 'items' in schema_obj and isinstance(schema_obj['items'], dict):
        _process_schema_object(schema_obj['items'])
    
    # Handle allOf, oneOf, anyOf
    for combiner in ['allOf', 'oneOf', 'anyOf']:
        if combiner in schema_obj:
            for sub_schema in schema_obj[combiner]:
                if isinstance(sub_schema, dict):
                    _process_schema_object(sub_schema)


def _process_paths(paths: Dict[str, Any]) -> None:
    """
    Process paths in the OpenAPI schema to clamp integer bounds.
    
    Args:
        paths: Dictionary of paths to process
    """
    for path, path_item in paths.items():
        for method, operation in path_item.items():
            if method in ['get', 'post', 'put', 'delete', 'patch', 'head', 'options', 'trace']:
                # Process parameters
                if 'parameters' in operation:
                    for param in operation['parameters']:
                        if 'schema' in param:
                            _process_schema_object(param['schema'])
                
                # Process request body
                if 'requestBody' in operation and 'content' in operation['requestBody']:
                    for content_type, media_type in operation['requestBody']['content'].items():
                        if 'schema' in media_type:
                            _process_schema_object(media_type['schema'])
                
                # Process responses
                if 'responses' in operation:
                    for status, response in operation['responses'].items():
                        if 'content' in response:
                            for content_type, media_type in response['content'].items():
                                if 'schema' in media_type:
                                    _process_schema_object(media_type['schema'])


def _clamp_integer_bounds(schema_obj: Dict[str, Any]) -> None:
    """
    Clamp the minimum and maximum values of an integer schema to SQLite's safe range.
    
    Args:
        schema_obj: Integer schema object to clamp
    """
    # Set maximum if not set or if set higher than SQLite limit
    if 'maximum' not in schema_obj or schema_obj['maximum'] > SQLITE_MAX_INT:
        schema_obj['maximum'] = SQLITE_MAX_INT
    
    # Set minimum if not set or if set lower than SQLite limit
    if 'minimum' not in schema_obj or schema_obj['minimum'] < SQLITE_MIN_INT:
        schema_obj['minimum'] = SQLITE_MIN_INT
    
    # Handle exclusiveMinimum/exclusiveMaximum if present
    if schema_obj.get('exclusiveMaximum', False) and schema_obj['maximum'] >= SQLITE_MAX_INT:
        schema_obj['maximum'] = SQLITE_MAX_INT - 1
        schema_obj['exclusiveMaximum'] = False
    
    if schema_obj.get('exclusiveMinimum', False) and schema_obj['minimum'] <= SQLITE_MIN_INT:
        schema_obj['minimum'] = SQLITE_MIN_INT + 1
        schema_obj['exclusiveMinimum'] = False
