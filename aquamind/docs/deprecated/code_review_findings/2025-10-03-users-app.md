## Overview

Audit of the `apps.users` package uncovered several critical gaps in access control, consistency, and resiliency. The focus areas were the REST serializers/viewsets, Django signals, and profile management utilities that underpin authentication flows.

## Key Findings

### 1. Privilege Escalation via Profile Update (Critical)
- **What we saw:** `UserProfileView` exposes `UserProfileUpdateSerializer`, allowing any authenticated caller to modify `profile.role`, `geography`, and `subsidiary`. `UserSerializer.update` honors the same fields during partial updates. A malicious user can update their profile role to `ADMIN`, after which `UserViewSet.get_queryset` grants them visibility over all accounts.
- **Why it matters:** This is a direct escalation path to administrative capabilities and complete user data exposure.
- **Mitigation ideas:**
  - Strip RBAC fields from user-facing serializers or gate them behind dedicated admin-only endpoints.
  - Perform server-side enforcement (e.g., ignore RBAC fields unless the requester is staff/superuser).
  - Add regression tests asserting standard users cannot mutate RBAC attributes.

### 2. Duplicate Signal Handlers (High)
- **What we saw:** Identical `post_save` receivers are defined in both `apps.users.models` and `apps.users.signals`. Each user save fires the handlers twice, causing redundant saves and duplicate entries in historical audit tables.
- **Why it matters:** Inflates history logs, adds unnecessary DB writes, and risks inconsistent behavior if the handlers ever diverge.
- **Mitigation ideas:** Consolidate the signal registration in one module (prefer `apps.users.signals`) and ensure `UsersConfig.ready()` imports only that module.

### 3. Profile Read/Write Serializer Mismatch (Medium)
- **What we saw:** `UserProfileView` returns `UserProfileSerializer`, which omits `full_name`, `phone`, and RBAC fields that the update serializer accepts. Clients cannot confirm persisted values without issuing an additional `me` call.
- **Why it matters:** Produces confusing API behavior and complicates UI workflows; also hides RBAC state from legitimate admins.
- **Mitigation ideas:** Unify the GET/PUT fields (e.g., extend the read serializer or reuse the update serializer with read-only RBAC fields). Update tests to cover the contract.

### 4. User Creation Consistency (Low)
- **What we saw:** `UserSerializer.create` calls `User.objects.create(...)` and sets passwords afterward.
- **Why it matters:** Bypasses built-in normalization (`create_user`) and risks stored plaintext passwords if an exception occurs before `set_password` saves the instance.
- **Mitigation ideas:** Use `User.objects.create_user(**validated_data)` or wrap creation in an atomic transaction.

### 5. Missing Profile Handling (Low)
- **What we saw:** `UserProfileView.get_object` assumes a profile exists; if signals fail or data is imported, the endpoint raises a 500 error.
- **Why it matters:** Fragile behavior when onboarding legacy data or bulk imports.
- **Mitigation ideas:** Use `get_or_create` fallback and log anomalies so operations can reconcile missing profiles.

## Suggested Next Steps

1. Prioritize blocking RBAC field updates by non-admins; add unit and integration coverage.
2. Remove duplicated signal handlers and verify history event counts before/after.
3. Align profile serializers and update API docs/tests accordingly.
4. Refactor user creation to rely on `create_user` and wrap in `transaction.atomic()`.
5. Harden profile retrieval with graceful recovery logic and monitoring hooks for missing profiles.

These remediations address immediate risks while leaving space for future enhancements—such as formalizing role permission matrices or expanding audit trails—to be explored by other droids.
