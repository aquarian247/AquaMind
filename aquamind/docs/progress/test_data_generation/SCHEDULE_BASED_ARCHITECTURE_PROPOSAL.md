# Schedule-Based Test Data Generation Architecture

**Problem:** Dynamic container allocation causes race conditions in parallel execution  
**Solution:** Pre-planned deterministic schedule eliminates races entirely  
**Benefit:** 100% success rate + reproducible + supports migration testing

---

## ğŸ¯ The Core Insight

**Current Approach (Dynamic):**
```
Runtime â†’ Query available containers â†’ Race condition â†’ 50-90% success rate
```

**Proposed Approach (Schedule-Based):**
```
Pre-plan â†’ Read schedule â†’ Execute deterministically â†’ 100% success rate
```

---

## ğŸ“‹ Schedule File Format

### `config/batch_generation_schedule.yaml`

```yaml
# Test Data Generation Schedule
# Generated by: schedule_planner.py
# Saturation: 85% (170 batches across 2,017 containers)
# Timespan: 7 years (2018-11-05 to 2025-11-18)

metadata:
  total_batches: 170
  saturation_target: 0.85
  stagger_days: 30
  start_date: 2018-11-05
  infrastruct:
    total_containers: 2017
    faroe_freshwater_stations: 14
    faroe_sea_areas: 23
    scotland_freshwater_stations: 11
    scotland_sea_areas: 20

batches:
  # Faroe Islands Batch 1
  - batch_id: FI-2018-001
    start_date: 2018-11-05
    eggs: 3500000
    duration: 900  # Full lifecycle
    geography: Faroe Islands
    
    # Pre-allocated infrastructure
    station: FI-FW-01
    sea_area: FI-SEA-01
    
    # Container assignments by stage (deterministic)
    containers:
      egg_alevin:
        hall: FI-FW-01-Hall-A
        containers: [C01, C02, C03, C04, C05, C06, C07, C08, C09, C10]
      fry:
        hall: FI-FW-01-Hall-B
        containers: [C01, C02, C03, C04, C05, C06, C07, C08, C09, C10]
      parr:
        hall: FI-FW-01-Hall-C
        containers: [C01, C02, C03, C04, C05, C06, C07, C08, C09, C10]
      smolt:
        hall: FI-FW-01-Hall-D
        containers: [C01, C02, C03, C04, C05, C06, C07, C08, C09, C10]
      post_smolt:
        hall: FI-FW-01-Hall-E
        containers: [C01, C02, C03, C04, C05, C06, C07, C08, C09, C10]
      adult:
        area: FI-SEA-01
        containers: [Ring-01, Ring-02, ..., Ring-10]
  
  # Faroe Islands Batch 2 (30 days later, different station)
  - batch_id: FI-2018-002
    start_date: 2018-12-05
    eggs: 3600000
    duration: 900
    geography: Faroe Islands
    station: FI-FW-02  # Different station, no conflict with Batch 1
    sea_area: FI-SEA-02
    containers:
      egg_alevin:
        hall: FI-FW-02-Hall-A
        containers: [C01, C02, ...]  # Different hall, no conflict
      # ...
  
  # ... 168 more batches (85 Faroe + 85 Scotland)
```

---

## ğŸ—ï¸ Architecture Components

### 1. Schedule Planner (`generate_batch_schedule.py`)

**Purpose:** Create deterministic schedule file

**Logic:**
```python
def plan_170_batches():
    """
    Generate deterministic schedule for 170 batches.
    
    Rules:
    1. 30-day stagger (prevents overlap)
    2. Round-robin station allocation (prevents conflicts)
    3. Pre-allocate containers (deterministic selection)
    4. Validate no overlaps before saving
    """
    
    start_date = date.today() - timedelta(days=85*30 + 50)  # 7 years back
    schedule = []
    
    for geo in [Faroe, Scotland]:
        stations = list(geo.stations)  # 14 for Faroe, 11 for Scotland
        sea_areas = list(geo.sea_areas)  # 23 for Faroe, 20 for Scotland
        
        for i in range(85):  # 85 batches per geography
            batch_start = start_date + timedelta(days=i*30)
            
            # Deterministic station selection
            station = stations[i % len(stations)]
            sea_area = sea_areas[i % len(sea_areas)]
            
            # Pre-allocate containers
            containers = allocate_containers_for_batch(station, sea_area)
            
            schedule.append({
                'batch_id': f'{geo.code}-{batch_start.year}-{i+1:03d}',
                'start_date': batch_start,
                'station': station.name,
                'sea_area': sea_area.name,
                'containers': containers,  # Deterministic list
                ...
            })
    
    # Validate schedule (no overlaps)
    validate_no_conflicts(schedule)
    
    # Save to YAML
    save_schedule(schedule, 'config/batch_generation_schedule.yaml')
```

**Output:** Single YAML file with complete plan

---

### 2. Schedule Executor (`execute_batch_schedule.py`)

**Purpose:** Execute pre-planned schedule (no dynamic allocation!)

**Logic:**
```python
def execute_schedule(schedule_file, parallel_workers=1):
    """
    Execute batches according to pre-planned schedule.
    
    NO dynamic queries for containers.
    NO race conditions.
    100% deterministic.
    """
    
    schedule = load_yaml(schedule_file)
    
    if parallel_workers > 1:
        # Parallel execution (safe, no races)
        with mp.Pool(processes=parallel_workers) as pool:
            results = pool.map(execute_batch_from_schedule, schedule['batches'])
    else:
        # Sequential execution
        for batch_config in schedule['batches']:
            execute_batch_from_schedule(batch_config)

def execute_batch_from_schedule(config):
    """
    Execute single batch using PRE-ALLOCATED containers.
    
    Args:
        config: Dict from schedule (contains exact container names)
    """
    # NO querying for available containers!
    # Just use what's in the schedule
    
    hall_a = Hall.objects.get(name=config['containers']['egg_alevin']['hall'])
    containers = Container.objects.filter(
        hall=hall_a,
        name__in=config['containers']['egg_alevin']['containers']
    )
    
    # Create assignments directly (no availability check)
    for container in containers:
        BatchContainerAssignment.objects.create(
            batch=batch,
            container=container,  # Pre-determined, no conflict possible
            ...
        )
```

**Result:** 100% success rate, fully parallelizable

---

## ğŸ’¡ Benefits of Schedule-Based Approach

### 1. Eliminates Race Conditions
- âœ… No runtime queries for "available" containers
- âœ… Each batch knows its exact containers upfront
- âœ… Workers never compete
- âœ… 100% success rate

### 2. Deterministic & Reproducible
- âœ… Same schedule file â†’ Same data every time
- âœ… Version control the schedule (Git)
- âœ… Migration testing: predictable source â†’ predictable test data
- âœ… Debugging: exact container assignments known

### 3. Validation Before Execution
- âœ… Schedule planner validates no overlaps
- âœ… Catch conflicts at plan time (not execution)
- âœ… Dry-run reviews complete plan
- âœ… No surprises during 6-hour runs

### 4. Parallel-Friendly
- âœ… Each worker gets distinct pre-allocated containers
- âœ… No locks needed
- âœ… Can scale to 14+ workers safely
- âœ… True parallel performance (not I/O-limited by locks)

### 5. Human-Readable Plan
- âœ… YAML is reviewable
- âœ… Can manually tweak assignments
- âœ… Can see entire plan before executing
- âœ… Documentation built-in

---

## ğŸ—ï¸ Implementation Plan

### Phase 1: Schedule Planner (2 hours)

**Script:** `scripts/data_generation/generate_batch_schedule.py`

**Responsibilities:**
1. Calculate optimal batch count (saturation model)
2. Distribute across geographies (85 Faroe + 85 Scotland)
3. Round-robin station allocation (no conflicts)
4. Pre-allocate exact containers per stage
5. Validate schedule (no overlaps, no conflicts)
6. Output YAML file

**Output:** `config/batch_generation_schedule_170.yaml` (~2000 lines)

---

### Phase 2: Schedule Executor (1 hour)

**Script:** `scripts/data_generation/execute_batch_schedule.py`

**Responsibilities:**
1. Load schedule YAML
2. For each batch, pass config to event engine
3. Event engine uses PRE-ALLOCATED containers (no queries)
4. Parallel or sequential execution
5. Track success/failure per batch

**Key Change:** Event engine takes `container_schedule` parameter:
```python
class EventEngine:
    def __init__(self, start_date, eggs, geography, duration=900, container_schedule=None):
        # ...
        self.container_schedule = container_schedule  # Pre-allocated containers
    
    def create_batch(self):
        if self.container_schedule:
            # Use pre-allocated containers (deterministic)
            containers = Container.objects.filter(
                name__in=self.container_schedule['egg_alevin']['containers']
            )
        else:
            # Fallback: dynamic allocation (current behavior)
            containers = self.find_available_containers(...)
```

---

### Phase 3: Validation Tools (30 min)

**Script:** `scripts/data_generation/validate_schedule.py`

**Checks:**
1. No container used by multiple batches at same time
2. All referenced containers exist in database
3. Station/area capacity not exceeded
4. Date-bounded batches stop at today
5. Total batches match saturation target

---

## ğŸ“Š Comparison: Current vs Schedule-Based

| Aspect | Current (Dynamic) | Schedule-Based | Winner |
|--------|-------------------|----------------|--------|
| Race conditions | âš ï¸ Yes (50-90% success) | âœ… None (100% success) | Schedule |
| Determinism | âŒ Random (varies per run) | âœ… Exact (reproducible) | Schedule |
| Debugging | âŒ Hard (which containers?) | âœ… Easy (known from schedule) | Schedule |
| Migration support | âŒ Non-deterministic | âœ… Deterministic source | Schedule |
| Parallelization | âš ï¸ Limited (locks needed) | âœ… Full (no conflicts) | Schedule |
| Setup time | âœ… None (dynamic) | âš ï¸ Generate schedule first | Current |
| Maintainability | âŒ Complex (round-robin + locks) | âœ… Simple (read file) | Schedule |

**Schedule-based wins 6/7 categories!**

---

## ğŸ¯ Migration Use Case (Critical!)

**Your Point About Migration:**

```python
# Migration from FishTalk (deterministic source data)
fishtalk_batch_123 â†’ AquaMind batch X
  - Same population trajectories
  - Same event dates
  - Same containers (if scheduled)
  - REPRODUCIBLE for testing
```

**With Deterministic Schedule:**
- Migration test 1: Source â†’ Schedule â†’ Verify
- Migration test 2: Re-run â†’ **Same result**
- **Testable and reproducible** âœ…

**Without Schedule (Current):**
- Migration test 1: Source â†’ Random containers
- Migration test 2: Re-run â†’ **Different containers**
- **Can't verify consistency** âŒ

---

## ğŸ”§ Proposed Schedule Planner Logic

```python
def generate_schedule(batches_per_geo=85, saturation=0.85):
    """
    Generate deterministic schedule for batch generation.
    
    Returns 170-batch plan with pre-allocated containers.
    """
    
    # Calculate timespan
    start_date = date.today() - timedelta(days=batches_per_geo*30 + 50)
    
    schedule = []
    container_occupancy = {}  # Track {container_id: [(start, end), ...]}
    
    for geo in [faroe, scotland]:
        stations = list(geo.stations.order_by('name'))  # Deterministic order
        sea_areas = list(geo.sea_areas.order_by('name'))
        
        for i in range(batches_per_geo):
            batch_start = start_date + timedelta(days=i*30)
            days_since_start = (date.today() - batch_start).days
            duration = min(900, days_since_start)  # Date-bounded
            
            # Deterministic station (round-robin)
            station = stations[i % len(stations)]
            sea_area = sea_areas[i % len(sea_areas)]
            
            # Pre-allocate containers for each stage
            containers = {
                'egg_alevin': allocate_stage_containers(station, 'A', i, container_occupancy),
                'fry': allocate_stage_containers(station, 'B', i, container_occupancy),
                'parr': allocate_stage_containers(station, 'C', i, container_occupancy),
                'smolt': allocate_stage_containers(station, 'D', i, container_occupancy),
                'post_smolt': allocate_stage_containers(station, 'E', i, container_occupancy),
                'adult': allocate_sea_containers(sea_area, i, container_occupancy),
            }
            
            # Update occupancy tracker
            update_occupancy(container_occupancy, batch_start, duration, containers)
            
            schedule.append({
                'batch_id': f'{geo.code}-{batch_start.year}-{i+1:03d}',
                'start_date': str(batch_start),
                'eggs': random.randint(3000000, 3800000),
                'duration': duration,
                'geography': geo.name,
                'station': station.name,
                'sea_area': sea_area.name,
                'containers': containers,
            })
    
    # Validate no conflicts
    validate_schedule(schedule, container_occupancy)
    
    return schedule

def allocate_stage_containers(station, hall_letter, batch_index, occupancy):
    """
    Allocate 10 containers for a stage, avoiding conflicts.
    
    Args:
        station: FreshwaterStation
        hall_letter: 'A', 'B', 'C', 'D', or 'E'
        batch_index: Batch number (for deterministic selection)
        occupancy: Current occupancy tracker
    
    Returns:
        List of container names (deterministic)
    """
    hall = Hall.objects.get(name=f'{station.name}-Hall-{hall_letter}')
    all_containers = list(Container.objects.filter(hall=hall).order_by('name'))
    
    # Deterministic selection based on batch index
    # With 30-day stagger and 90-day stages, ~3 batches can use same hall
    offset = (batch_index % 3) * 10  # Rotate through container sets
    selected = all_containers[offset:offset+10]
    
    return [c.name for c in selected]
```

---

## ğŸ¯ Implementation Steps

### Step 1: Create Schedule (1 hour)
```bash
cd /Users/aquarian247/Projects/AquaMind

# Generate schedule file
python scripts/data_generation/generate_batch_schedule.py \
  --batches 85 \
  --output config/batch_generation_schedule_170.yaml

# Validate schedule
python scripts/data_generation/validate_schedule.py \
  config/batch_generation_schedule_170.yaml

# Expected output:
# âœ… 170 batches planned
# âœ… Zero container conflicts detected
# âœ… 85% saturation achieved
# âœ… Schedule saved to config/batch_generation_schedule_170.yaml
```

### Step 2: Update Event Engine (30 min)
```python
# Modify EventEngine to accept pre-allocated containers
def __init__(self, ..., container_schedule=None):
    self.container_schedule = container_schedule

def create_batch(self):
    if self.container_schedule:
        # Deterministic: use scheduled containers
        containers = Container.objects.filter(
            name__in=self.container_schedule['egg_alevin']['containers']
        )
    else:
        # Fallback: dynamic (current behavior, for single-batch testing)
        containers = self.find_available_containers(...)
```

### Step 3: Create Schedule Executor (1 hour)
```bash
# Execute from schedule
python scripts/data_generation/execute_batch_schedule.py \
  config/batch_generation_schedule_170.yaml \
  --workers 14  # Now safe!
```

### Step 4: Test (30 min)
```bash
# Small test schedule (10 batches)
python scripts/data_generation/generate_batch_schedule.py \
  --batches 10 \
  --output config/test_schedule_20.yaml

# Execute
python scripts/data_generation/execute_batch_schedule.py \
  config/test_schedule_20.yaml \
  --workers 14

# Verify 100% success rate
```

---

## ğŸ Additional Benefits

### 1. Schedule is Documentation
- `batch_generation_schedule_170.yaml` shows EXACTLY what gets created
- Reviewable before execution
- Version controlled
- Self-documenting

### 2. Easy Customization
```bash
# Generate custom schedules
python generate_batch_schedule.py --batches 50  # Smaller test
python generate_batch_schedule.py --batches 200 --saturation 0.95  # Max capacity
python generate_batch_schedule.py --start-date 2015-01-01  # Longer history
```

### 3. Migration Alignment
```yaml
# migration_test_schedule.yaml
# Maps FishTalk data to AquaMind containers
batches:
  - batch_id: FI-2024-001
    source: fishtalk_population_456  # Link to migration source
    containers: [...]  # Exact same containers for testing
```

### 4. Infrastructure Testing
```bash
# Validate infrastructure capacity
python generate_batch_schedule.py --batches 300  # Over-provision
# Expected: Error (not enough containers)
# Validates infrastructure limits
```

---

## â° Timeline to Implement

**Total: ~3 hours + testing**

1. Schedule planner: 1 hour
2. Event engine updates: 30 min
3. Schedule executor: 1 hour
4. Validation tools: 30 min
5. Testing: 30 min

**Then: Generate 170 batches with 100% success rate** (5-6 hours)

---

## ğŸ¯ Acceptance Criteria

**For schedule-based approach to be DONE:**

âœ… Schedule planner generates valid YAML  
âœ… Validation tool catches conflicts  
âœ… Event engine uses scheduled containers  
âœ… Executor runs batches from schedule  
âœ… Test with 20 batches: 100% success rate  
âœ… Full 170 batches: 100% success rate  
âœ… Reproducible (same schedule â†’ same data)  
âœ… Documentation updated

---

## ğŸ’¬ Your Thoughts?

This architecture:
- âœ… Eliminates races (your requirement)
- âœ… Makes generation deterministic (your requirement)
- âœ… Supports migration testing (your requirement)
- âœ… Sustainable (agents just read schedule file)

**Worth the 3-hour implementation before generating 170 batches?**

Or should we:
- Accept current approach with some failures?
- Use sequential for 100% but slower?

---

**Let me know your preference. I'll wait for current generation to complete while you decide.**

---

