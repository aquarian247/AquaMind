"""CI-specific Django settings for AquaMind project.

This file extends the base settings and overrides database configuration for CI environments.
"""

from .settings import *  # noqa

# Override database settings for CI environment
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        # Use a persistent SQLite file so that both the migration step and the
        # subsequently-started dev-server share the same schema & data.
        # BASE_DIR comes from the base settings we just imported.
        'NAME': BASE_DIR / 'ci.sqlite3',
    }
}

# Ensure TEST_RUNNER from main settings is not overriding CI database behavior if it implies PostgreSQL
# If TimescaleDBTestRunner specifically requires PostgreSQL, this might need further adjustment
# For now, let's assume standard Django testing with SQLite is the goal for CI.
# If the custom runner has specific logic for CI, it should respect these settings.
TIMESCALE_ENABLED = False

# Speed up tests by using a weaker password hasher in CI if appropriate
# PASSWORD_HASHERS = [
#     'django.contrib.auth.hashers.MD5PasswordHasher',
# ]

# ---------------------------------------------------------------------------
# SQLite-specific compatibility tweaks
# ---------------------------------------------------------------------------
# ❶  Why?  SQLite stores INTEGER values as signed 64-bit numbers.  When
#     Schemathesis (or other property-based tools) generate arbitrarily large
#     integers, inserts can fail with:
#         OverflowError: Python int too large to convert to SQLite INTEGER
# ❷  Mitigation.  We clamp integer ranges in the generated OpenAPI schema
#     so that Schemathesis & client generators know the true bounds.
#     This is done via a small post-processing hook registered in
#     `aquamind.utils.openapi_utils.clamp_integer_schema_bounds`.
# ❸  The settings below enable drf-spectacular & REST framework to use that
#     hook during schema generation in CI.

# Minimal DRF settings override for CI
# ------------------------------------------------------------------
# Extend the REST_FRAMEWORK config defined in the base ``settings`` rather
# than blindly overwriting it.  This keeps global defaults (renderers,
# authentication classes, etc.) intact while ensuring the OpenAPI AutoSchema
# hook executes during CI.
# ------------------------------------------------------------------
try:
    BASE_REST_FRAMEWORK = REST_FRAMEWORK  # comes from ``from .settings import *``
except NameError:  # pragma: no cover – unlikely, but keep it safe
    BASE_REST_FRAMEWORK = {}

# Shallow-copy & override only what we need
REST_FRAMEWORK = {
    **BASE_REST_FRAMEWORK,
    # Ensure drf-spectacular's AutoSchema is active so our post-processing hook runs
    'DEFAULT_SCHEMA_CLASS': 'drf_spectacular.openapi.AutoSchema',
}

# drf-spectacular settings specific to the CI / SQLite environment
# ------------------------------------------------------------------
# Likewise, extend the project-wide SPECTACULAR_SETTINGS, only tweaking the
# keys that are important for CI / SQLite compatibility.
# ------------------------------------------------------------------
try:
    BASE_SPECTACULAR_SETTINGS = SPECTACULAR_SETTINGS  # noqa: F401
except NameError:  # pragma: no cover
    BASE_SPECTACULAR_SETTINGS = {}

_ci_spec_settings = dict(BASE_SPECTACULAR_SETTINGS)  # shallow copy

# 1) Keep output deterministic for easier diffing in CI logs
_ci_spec_settings['SORT_OPERATIONS'] = False

# 2) Append (or add) our post-processing hook that clamps integer ranges
hook_path = 'aquamind.utils.openapi_utils.clamp_integer_schema_bounds'
_ci_hooks = _ci_spec_settings.get('POSTPROCESSING_HOOKS', [])
if hook_path not in _ci_hooks:
    _ci_hooks.append(hook_path)

# 3) Ensure a *global* security requirement exists
#    ------------------------------------------------
#    drf-spectacular will only emit a top-level ``security`` block if every
#    single operation explicitly declares one – an easy thing to miss that
#    results in anonymous requests during Schemathesis runs.
#    The hook below forcibly injects::
#
#        security:
#          - tokenAuth: []
#
#    when the block is absent, guaranteeing that contract-test tooling sends
#    authentication headers by default.
ensure_hook_path = 'aquamind.utils.openapi_utils.ensure_global_security'
if ensure_hook_path not in _ci_hooks:
    _ci_hooks.append(ensure_hook_path)

# 4) Append additional hook that removes duplicate security entries
#    generated by drf-spectacular.  Keeping this separate from the clamp
#    hook allows each transformation to stay single-purpose and easier
#    to test in isolation.
dup_hook_path = 'aquamind.utils.openapi_utils.cleanup_duplicate_security'
if dup_hook_path not in _ci_hooks:
    _ci_hooks.append(dup_hook_path)

# 5) [REMOVED] Infrastructure endpoints have been restored
#    ---------------------------------------------------------------
#    The prune_legacy_paths hook was temporarily used during Phase-4
#    to strip infrastructure paths from the schema. Now that the router
#    duplication issue is resolved, we've restored these endpoints and
#    no longer need to prune them from the schema.
# prune_hook_path = 'aquamind.utils.openapi_utils.prune_legacy_paths'
# if prune_hook_path not in _ci_hooks:
#     _ci_hooks.append(prune_hook_path)

# 6) Append hook that documents *400 validation errors* for write ops
#    ---------------------------------------------------------------
#    A minimal, surgical hook that injects a ``400`` response only for
#    POST / PUT / PATCH requests and GETs that include a ``page`` query
#    parameter – avoiding an over-broad schema while satisfying
#    Schemathesis' status-code-conformance check.
val_hook_path = 'aquamind.utils.openapi_utils.add_validation_error_responses'
if val_hook_path not in _ci_hooks:
    _ci_hooks.append(val_hook_path)

# 7) Append hook that inserts **standard 401 / 403 / 404 / 500 responses**
#    ---------------------------------------------------------------
#    This keeps Schemathesis from flagging “undocumented status code”
#    failures whenever the implementation legitimately returns a 404 for a
#    non-existent object or a 401 / 403 for failed authentication.
#    The hook injects minimal stubs (description-only) so we don’t need to
#    hand-annotate every single operation.
std_hook_path = 'aquamind.utils.openapi_utils.add_standard_responses'
if std_hook_path not in _ci_hooks:
    _ci_hooks.append(std_hook_path)

# 8) Append hook that fixes **@action list-response schemas**
#    ---------------------------------------------------------------
#    Several custom ``@action(detail=False)`` endpoints legitimately return
#    **arrays** (e.g. ``/recent/``, ``/stats/``, ``/by_batch/``) but
#    drf-spectacular documents them with the single-object serializer,
#    causing Schemathesis type-mismatch errors.  The hook below wraps such
#    schemas in ``type: array`` when appropriate.
act_hook_path = 'aquamind.utils.openapi_utils.fix_action_response_types'
if act_hook_path not in _ci_hooks:
    _ci_hooks.append(act_hook_path)

_ci_spec_settings['POSTPROCESSING_HOOKS'] = _ci_hooks

# Final CI-specific spectacular config
SPECTACULAR_SETTINGS = _ci_spec_settings

# ------------------------------------------------------------------
# TEMPORARY: Phase-1 debugging middleware for auth-header inspection
# ------------------------------------------------------------------
try:
    BASE_MIDDLEWARE = MIDDLEWARE  # Imported from base settings
except NameError:  # pragma: no cover – should not happen but stay safe
    BASE_MIDDLEWARE = []

# Only append if it's not already in the stack to avoid duplicates when this
# file is re-evaluated (e.g. in Django's autoreload).
_debug_mw = 'aquamind.middleware.AuthHeaderDebugMiddleware'
if _debug_mw not in BASE_MIDDLEWARE:
    MIDDLEWARE = [*BASE_MIDDLEWARE, _debug_mw]
else:
    MIDDLEWARE = BASE_MIDDLEWARE

# Persist debug logs to a file so CI can expose them as an artifact if needed.
# (The GitHub workflow can upload this file for inspection.)
AUTH_DEBUG_LOG_FILE = BASE_DIR / 'auth-debug.log'
