# API Contract Synchronization Guide  
_AquaMind ⊕ AquaMind-Frontend · last updated Aug 2025_

## 1 Purpose
Keep backend and frontend in **lock-step** by propagating every change to  
`api/openapi.yaml` (OpenAPI 3.1, generated by **drf-spectacular ≥ 0.28**).  
Outcome: type-safe React client, zero hand-coded DTO drift, and green Schemathesis.

---

## 2 Automatic Flow (fully operational)

| Step | Repo · Workflow | Key Action |
|------|-----------------|------------|
| 1 | **AquaMind** · `django-tests.yml` | After tests + Schemathesis, upload artifact:<br>`actions/upload-artifact@v4` → **name: `api-spec`** |
| 2 | **AquaMind** · `sync-openapi-to-frontend.yml` | `repository_dispatch` to `aquarian247/AquaMind-Frontend` <br>`event-type: api-spec-updated` <br>Token: `${{ secrets.FRONTEND_REPO_PAT }}` |
| 3 | **AquaMind-Frontend** · `regenerate-api-client.yml` | `curl` raw spec via commit hash:<br>`https://raw.githubusercontent.com/aquarian247/AquaMind/<sha>/api/openapi.yaml` → `tmp/openapi/openapi.yaml` |
| 4 | same job | `npm run generate:api` (openapi-typescript-codegen) |
| 5 | same job | `git diff` → if changed, PR `auto/api-client-update` to **main** |

### Secrets & Permissions
* **FRONTEND_REPO_PAT** (backend repo) – classic PAT with `repo` scope, write access to frontend.
* **GITHUB_TOKEN** (frontend) – default; repo Settings → Actions → Read/Write + "create PRs".

---

## 3 Manual Fallback

If dispatch fails (e.g. PAT expired):

1. Frontend repo → Actions → **"Manual API Client Sync"**  
2. Input backend branch (`main` or feature) → Run workflow  
3. Same steps 3-5 above; PR created.

---

## 4 Contract Testing Quick-Ref

**Note** Contract validation is enforced in **two complementary layers**:  
• **Static contract tests** (`tests/contract/`) – quick structural checks (see `quality_assurance/testing_guide.md`)  
• **Schemathesis** – dynamic, property-based HTTP testing (commands below)

| Context | Command |
|---------|---------|
| Local full suite | `coverage run --source='.' manage.py test && coverage report` |
| Contract only (10 ex) | `schemathesis run --hypothesis-max-examples 10 api/openapi.yaml` |
| Hooks module | `aquamind.utils.schemathesis_hooks` (export as `SCHEMATHESIS_HOOKS`) |
| Auth token (CI settings) | `python manage.py get_ci_token --settings=aquamind.settings_ci` |
| Validate spec | `python manage.py validate_openapi --check` |
| Fix spec issues | `python manage.py validate_openapi --fix` |

---

## 4.5 Router Registration Standards

Keeping DRF routers consistent is **critical** to a stable OpenAPI spec and to avoiding 404 / duplicate-route noise during Schemathesis runs.

### DRF Router Guidelines

| Principle | Implementation |
|-----------|----------------|
| **One router per app** | Create `api/routers.py` inside every app; instantiate its own `DefaultRouter` & perform all registrations there. |
| **Explicit basenames** | Always supply `basename=` and use **kebab-case** (`growth-samples`, `feed-containers`). |
| **Project-wide unique** | A basename must not collide with any other app's basename. |
| **No registry merging** | Never call `router.registry.extend()` – include routers via `path('', include(...))` instead. |

### Preventing Duplicate Endpoints

Common pitfalls that introduce URL conflicts:  
* Relying on auto-generated basenames (missing `basename=`).  
* Copy-pasting routers and later calling `router.registry.extend()`.  
* Mixing camelCase / snake_case / kebab-case between apps.  

### Validation Checklist ✅

Before committing router changes, ensure:

- [ ] All ViewSets have **explicit kebab-case basenames**.  
- [ ] `python manage.py show_urls | sort` shows **no duplicates**.  
- [ ] Full test-suite passes (`coverage run …`).  
- [ ] Schemathesis run is green (no unexpected 404 / duplicate warnings).  
- [ ] Any changed basenames are reflected in tests (`reverse('<basename>-list')`).  

---

## 5 Automated Spec Maintenance

### 5.1 Pre-commit Hooks

The repository includes pre-commit hooks that automatically regenerate the OpenAPI spec when API code changes:

```yaml
# Custom hook to regenerate OpenAPI spec (.pre-commit-config.yaml)
- repo: local
  hooks:
    - id: regenerate-openapi-spec
      name: Regenerate OpenAPI Spec
      entry: python manage.py spectacular --file api/openapi.yaml
      language: system
      files: >
        (apps/.+/(api|viewsets|serializers|routers)/.+\.py)|
        (aquamind/api/.+\.py)|
        (aquamind/utils/openapi_utils\.py)
      types: [python]
      stages: [commit]
```

Install pre-commit hooks with:
```bash
pip install pre-commit
pre-commit install
```

### 5.2 Helper Script

For manual regeneration:
```bash
./scripts/regenerate_openapi.sh
```

This script:
1. Regenerates the spec using the Django management command
2. Stages changes for commit if the spec was updated

### 5.3 OpenAPI Validation Command

The `validate_openapi` management command provides comprehensive validation:

```bash
# Check if the spec is valid and in sync
python manage.py validate_openapi

# Fix issues automatically
python manage.py validate_openapi --fix

# CI mode (exit with error code on failure)
python manage.py validate_openapi --check

# Run with Schemathesis validation
python manage.py validate_openapi --schemathesis
```

### 5.4 Automated Testing

The test suite includes comprehensive OpenAPI spec validation:

```bash
# Run all OpenAPI spec tests
python manage.py test apps.infrastructure.tests.test_openapi_spec
```

These tests verify:
- Schema generation without errors
- Schema validation against OpenAPI standards
- Response code documentation (200, 401, 403, 404, 500)
- Integer field bounds for SQLite compatibility
- Security requirements documentation
- Spectacular hook configuration
- Inclusion of all viewsets and custom actions

### 5.5 GitHub Workflow Checks

The `.github/workflows/openapi-spec-check.yml` workflow:
- Runs on every PR that modifies API-related files
- Generates a fresh OpenAPI spec and compares with committed version
- Fails if they don't match, with detailed error information
- Provides instructions on how to fix the issue

---

## 6 Troubleshooting Checklist

| Symptom | Likely Cause · Fix |
|---------|-------------------|
| `Resource not accessible by token` in backend sync | PAT missing `repo` scope or wrong user permissions |
| Frontend workflow "Artifact not found" | Using old artifact download step – _should use **curl**_ |
| PR not created | No diff (spec unchanged) _or_ repo Settings "Allow PRs" disabled |
| Schemathesis SQLite overflow | Ensure hook `clamp_integer_schema_bounds` active |
| Missing response codes | Ensure `add_standard_responses` hook is configured properly |
| Out-of-sync specification | Run `./scripts/regenerate_openapi.sh` and commit changes |
| Schema validation errors | Check serializers for proper type hints and `@extend_schema_field` annotations |
| Hook configuration issues | Verify all 6 required hooks are in `settings.py` and `settings_ci.py` |

### Required Hooks Configuration

Ensure these hooks are configured in both `settings.py` and `settings_ci.py`:

```python
SPECTACULAR_SETTINGS = {
    # ... other settings ...
    'POSTPROCESSING_HOOKS': [
        'aquamind.utils.openapi_utils.ensure_global_security',
        'aquamind.utils.openapi_utils.add_standard_responses',
        'aquamind.utils.openapi_utils.fix_action_response_types',
        'aquamind.utils.openapi_utils.cleanup_duplicate_security',
        'aquamind.utils.openapi_utils.add_validation_error_responses',
        'aquamind.utils.openapi_utils.clamp_integer_schema_bounds',
    ],
}
```

---

## 7 Developer Workflow Guidelines

### 7.1 When Adding or Modifying Endpoints

1. Implement the endpoint with proper docstrings and type hints
2. Run `./scripts/regenerate_openapi.sh` to update the spec
3. Run `python manage.py validate_openapi` to verify completeness
4. Commit both the implementation and updated spec together

### 7.2 Response Code Standards

All endpoints must document:
- `200` - Successful response
- `401` - Unauthorized (missing authentication)
- `403` - Forbidden (insufficient permissions)
- `500` - Internal Server Error

Additional codes based on endpoint type:
- Detail endpoints: `404` - Not Found
- Write operations: `400` - Validation Error

### 7.3 Documentation Best Practices

```python
@extend_schema(
    description="Retrieves infrastructure overview statistics",
    responses={
        200: InfrastructureOverviewSerializer,
        401: OpenApiResponse("Unauthorized"),
        403: OpenApiResponse("Forbidden"),
        500: OpenApiResponse("Internal Server Error"),
    },
    tags=["infrastructure"]
)
def get(self, request):
    """
    Get infrastructure overview statistics.
    
    Returns aggregated data about containers, biomass, and feeding events.
    """
    # Implementation...
```

---

## 8 File & Script Map

| File | Purpose |
|------|---------|
| **backend** `api/openapi.yaml` | Single source of truth (auto-generated) |
| `.github/workflows/django-tests.yml` | Generates spec & artifact |
| `.github/workflows/sync-openapi-to-frontend.yml` | Dispatch event to frontend |
| `.github/workflows/openapi-spec-check.yml` | Validates spec matches implementation |
| `scripts/regenerate_openapi.sh` | Helper script for manual spec regeneration |
| `apps/infrastructure/tests/test_openapi_spec.py` | Comprehensive spec validation tests |
| `apps/infrastructure/management/commands/validate_openapi.py` | Management command for validation |
| `.pre-commit-config.yaml` | Configures automatic spec regeneration |
| **frontend** `.github/workflows/regenerate-api-client.yml` | Fetch spec & rebuild client |
| `package.json` → `generate:api` | `openapi --input tmp/openapi/openapi.yaml --output client/src/api/generated --client fetch --useUnionTypes` |

---

Stay contract-first: _any serializer / viewset change → regenerate spec → commit → CI takes it from there._  
When in doubt, run `npm run generate:api` locally and push the PR manually.
